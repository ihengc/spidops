SO_LINGER套接字选项

级别：SOL_SOCKET
本选项指定close函数对面向连接的协议（如TCP或SCTP）如何操作。
close的默认操作是立即返回，但是如果有数据在套接字发送缓冲区中，系统将试着把这些数据发送给对端。

本选项要求在用户进程与内核间传递如下结构：
<sys/socket.h>
struct linger {
    int l_onoff;
    int l_linger;
};

对setsockopt的调用将根据其中两个结构成员的值形成下列3种情形之一（SO_LINGER的3种使用方式）
1. 如果l_onoff为0，那么关闭本选项。l_linger的值被忽略，close是默认情况（立即返回）。

2. 如果l_onoff非0且l_linger为0，那么当close某个连接时TCP将中止该连接。TCP将丢弃保留在套接字发送缓冲区种的任何数据，并发送一个RST
给对端，而没有通常的四分组连接终止序列。这样会避免TCP的TIME_WAIT状态，但是可能会：在2MSL秒内创建该连接的另一个化身，导致来自刚被终
止的连接上的旧的重复分节被不正确地递送到新的化身上。

3. 如果l_onoff非0且l_linger也为非0，那么当套接字关闭时内核将拖延一段时间。这就是说如果套接字发送缓冲区有残留的数据，那么进程将被投
入睡眠，直到所有数据都已发送完且均被对端确认或延滞时间到。如果套接字被设置为非阻塞型，即使延滞时间为非0，进程也不会等待close完成。


当使用SO_LINGER套接字选项时，应用进程应该去检查close的返回值，因为如果在数据发送完并被确认之前延滞时间到的话，close将返回EWOULDBLOCK
错误，且套接字发送缓冲区中的任何残留数据都将被丢弃。

情景一（默认情况）：
客户端 <-> 服务端
    write -> 数据 - > 由TCP排队数据
    close（close默认立即返回） -> FIN
    <- 数据和FIN的确认
    <- FIN
    数据和FIN确认 ->

设置SO_LINGER套接字选项后，close的成功返回只是告诉我们先前发送的数据（和FIN）已由对端TCP确认，而不能告诉我们对端应用进程是否已读取
数据。

情景二（使用SO_LINGER套接字选项设置一个延滞时间）：
客户端 <-> 服务器
    write -> 数据 -> 由TCP排队数据
    close -> FIN
    close返回 <- 数据和FIN的确认（应用进程读排队的数据和FIN）
    <- FIN <- close
    数据和FIN的确认 ->


情景三（使用SO_LINGER套接字选项设置一个偏低的延滞时间值）；
客户端 <-> 服务器
